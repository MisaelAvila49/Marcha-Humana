import cv2
import mediapipe as mp
import numpy as np

# Función para calcular el ángulo
def angle(a, b, c):
    ba = a - b
    bc = c - b
    cosine_angle = np.dot(ba, bc) / (np.linalg.norm(ba) * np.linalg.norm(bc))
    cosine_angle = np.clip(cosine_angle, -1.0, 1.0)
    ang = np.degrees(np.arccos(cosine_angle))
    if ang > 180:
        ang = ang - 180
    if ang < 90:
        ang = 180 - ang
    ang = abs(round(ang))
    return [ang, b]

# Inicializar mediapipe
mp_pose = mp.solutions.pose
mp_drawing = mp.solutions.drawing_utils

# Colores y parámetros
CL = (130,140,40)
CP = (205,218,56)
CCI, CRI, CTOI = (30,180,200), (30,120,200), (30,60,200)
CCD, CRD, CTOD = (200,180,30), (200,120,30), (200,60,30)
font = cv2.FONT_HERSHEY_PLAIN
text_color = (0, 0, 0)
T1 = 2
T2 = T1 + 1

cap = cv2.VideoCapture(0)

with mp_pose.Pose(static_image_mode=False, model_complexity=2, min_detection_confidence=0.5) as pose:
    while True:
        ret, frame = cap.read()
        if not ret:
            break

        H, W, _ = frame.shape
        CXI, CXD = round(W/55), -round(W/17)
        image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(image_rgb)
        image = frame.copy()

        try:
            landmarks = results.pose_landmarks.landmark

            # Obtener puntos relevantes
            puntos = {}
            indices = {
                'N': 0, 'H_I': 11, 'H_D': 12, 'C_I': 23, 'C_D': 24,
                'R_I': 25, 'R_D': 26, 'TO_I': 27, 'TO_D': 28,
                'TA_I': 29, 'TA_D': 30
            }
            for k, i in indices.items():
                puntos[k] = np.multiply([landmarks[i].x, landmarks[i].y], [W, H]).astype(int)

            # Dibujar pose
            mp_drawing.draw_landmarks(image, results.pose_landmarks, mp_pose.POSE_CONNECTIONS,
                                      mp_drawing.DrawingSpec(CL, T2, T2),
                                      mp_drawing.DrawingSpec(CP, T2, T2))

            # Mostrar ángulos lado derecho solo si se observan bien
            if all(landmarks[i].visibility > 0.5 for i in [24, 26, 28]):
                DCD = angle(puntos['H_D'], puntos['C_D'], puntos['R_D'])
                DRD = angle(puntos['C_D'], puntos['R_D'], puntos['TO_D'])
                DTOD = angle(puntos['R_D'], puntos['TO_D'], puntos['TA_D'])
                DRD[0] = 180 - DRD[0]
                DTOD[0] = 180 - (DTOD[0] - 45)

                # Dibujamos los angulos con su texto
                for ang, pos, color in zip([DCD, DRD, DTOD], [DCD[1], DRD[1], DTOD[1]], [CCD, CRD, CTOD]):
                    cv2.circle(image, pos, T2*2, color, -1)
                    cv2.putText(image, str(ang[0]), np.array(pos) + [CXI, -1], font, T1, color, T2)

            # Mostrar ángulos lado izquierdo solo si se observan bien
            if all(landmarks[i].visibility > 0.5 for i in [23, 25, 27]):
                DCI = angle(puntos['H_I'], puntos['C_I'], puntos['R_I'])
                DRI = angle(puntos['C_I'], puntos['R_I'], puntos['TO_I'])
                DTOI = angle(puntos['R_I'], puntos['TO_I'], puntos['TA_I'])
                DRI[0] = 180 - DRI[0]
                DTOI[0] = 180 - (DTOI[0] - 45)

                # Dibujamos los angulos con su texto
                for ang, pos, color in zip([DCI, DRI, DTOI], [DCI[1], DRI[1], DTOI[1]], [CCI, CRI, CTOI]):
                    cv2.circle(image, pos, T2*2, color, -1)
                    cv2.putText(image, str(ang[0]), np.array(pos) + [CXD, -1], font, T1, color, T2)

        except Exception as e:
            print(f"Error: {e}")

        cv2.imshow("Estimacion de Angulos", image)
        if cv2.waitKey(1) & 0xFF == 27:  # Salir con ESC
            break

cap.release()
cv2.destroyAllWindows()